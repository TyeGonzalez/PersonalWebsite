<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Legendre Polynomials and Spatial Reasoning</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      /* Scrollable sidebar styling */
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 350px;
        max-height: 90vh;
        overflow-y: auto;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        font-family: sans-serif;
        font-size: 14px;
        line-height: 1.4;
      }
    </style>
    <!-- Import map for three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js"
        }
      }
    </script>
    <!-- MathJax for rendering LaTeX -->
    <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
  </head>
  <body>
  <div id="info">
      <h2>Legendre Polynomials in 3D</h2>
      <p>
        Many physical problems on a sphere (like how a rank‑2 tensor affects a property such as chemical shift anisotropy) involve variations that follow a pattern. The second‑order Legendre polynomial is:
      </p>
      <p>
        $$ P_2(\cos\theta)=\frac{3\cos^2\theta-1}{2} $$
      </p>
      <p>
        Think of it this way: the sphere's points near the top (or bottom) are treated differently from those at the equator.
        At the poles, where \( \cos\theta \) is \( \pm 1 \), \( P_2 \) is positive (leading to stretching), and at the equator, where \( \cos\theta=0 \), \( P_2 \) is negative (leading to compression). This creates a natural “two-peak” pattern that fits well with many spherical phenomena.
      </p>
      <hr/>
      <h3>Quadrupolar Symmetry</h3>
      <p>
        The term "quadrupolar" describes a spatial pattern with a four-lobe (or four-region) distribution. For the Legendre polynomial:
      </p>
      <p>
        $$ P_2(\cos\theta)=\frac{3\cos^2\theta-1}{2} $$
      </p>
      <p>
        This function is positive at the poles (\( \cos\theta=\pm 1 \)) and negative at the equator (\( \cos\theta=0 \)). Such a pattern is characteristic of quadrupolar symmetry.
      </p>
      <ul>
        <li><strong>Axial Symmetry:</strong> The pattern is symmetric around a particular axis (commonly the z‑axis). Rotating about this axis leaves the pattern unchanged.</li>
        <li><strong>Sign Change Across a Nodal Plane:</strong> There’s a plane (or ring, such as the equator) where the function goes to zero and changes sign.</li>
        <li><strong>Even Parity:</strong> The function remains unchanged if the direction along the symmetry axis is inverted.</li>
      </ul>
      <p>
        In NMR, chemical shift anisotropy (CSA) is described by a second‑rank tensor. This means the angular dependence of CSA naturally follows quadrupolar symmetry (i.e., it varies like \( P_2(\cos\theta) \)) because the electron density around the nucleus is not uniform—it can be elongated or compressed along different directions.
      </p>
      <p>
        In our visualization, we deform a sphere radially by a factor of \( 1 + \text{amplitude} \times P_2(\cos\theta) \). Adjust the slider to see how the sphere is stretched near the poles and squeezed at the equator.
      </p>
    </div>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js";
      import * as dat from "https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.module.js";
      import { ParametricGeometry } from "https://threejs.org/examples/jsm/geometries/ParametricGeometry.js";

      // Create the scene, camera, and renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(3, 3, 3);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Set up orbit controls for navigation
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Add basic lighting
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      // Legendre polynomial P2 function: P2(x) = (3x² - 1)/2
      function legendre2(x) {
        return (3 * x * x - 1) / 2;
      }

      // Parameters for our sphere and deformation
      const radius = 1;
      const widthSegments = 64;
      const heightSegments = 64;
      let amplitude = 1; // initial deformation amplitude

      // Function to create the deformed sphere geometry with vertex colors
      function createDeformedSphere() {
        // Create a sphere geometry
        const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
        const posAttr = geometry.attributes.position;
        const count = posAttr.count;

        // Prepare an array to store vertex colors (RGB for each vertex)
        const colors = new Float32Array(count * 3);

        // Loop over each vertex of the sphere
        for (let i = 0; i < count; i++) {
          const vertex = new THREE.Vector3();
          vertex.fromBufferAttribute(posAttr, i);

          // In this setup, the y-axis is “up”, so the polar angle θ is given by cosθ = y / radius.
          const cosTheta = vertex.y / radius;

          // Compute the deformation factor using P2(cosθ)
          const legVal = legendre2(cosTheta);
          const factor = 1 + amplitude * legVal;

          // Displace the vertex radially
          vertex.multiplyScalar(factor);
          posAttr.setXYZ(i, vertex.x, vertex.y, vertex.z);

          // Set the vertex color based on the sign of legendre value
          const color = new THREE.Color();
          if (legVal >= 0) {
            // Blue for positive values
            color.set(0x0000ff);
          } else {
            // Red for negative values
            color.set(0xff0000);
          }
          // Assign color components to the colors array
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
        }

        // Add the vertex colors attribute to the geometry
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.computeVertexNormals();
        return geometry;
      }

      // Create initial deformed sphere mesh with vertex colors
      let sphereGeometry = createDeformedSphere();
      const material = new THREE.MeshStandardMaterial({
        vertexColors: true, // Enable vertex colors
        side: THREE.DoubleSide,
        flatShading: false,
      });
      const sphereMesh = new THREE.Mesh(sphereGeometry, material);
      scene.add(sphereMesh);

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle window resizing
      window.addEventListener("resize", onWindowResize, false);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Set up dat.GUI to adjust the amplitude of the deformation interactively.
      const gui = new dat.GUI();
      gui.add({ amplitude: amplitude }, "amplitude", 0, 1).onChange((value) => {
        amplitude = value;
        // Dispose of the old geometry and create a new one with updated amplitude and colors
        const newGeometry = createDeformedSphere();
        sphereMesh.geometry.dispose();
        sphereMesh.geometry = newGeometry;
      });
    </script>
  </body>
</html>